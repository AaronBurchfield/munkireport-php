#!/usr/bin/python
# encoding: utf-8

from munkilib import munkicommon
from munkilib.phpserialize import *
import subprocess
import pwd
import sys
import urllib
from Foundation import NSArray, NSDate, NSMetadataQuery, NSPredicate
from Foundation import CFPreferencesAppSynchronize
from Foundation import CFPreferencesCopyAppValue
from Foundation import CFPreferencesCopyKeyList
from Foundation import CFPreferencesSetValue
from Foundation import kCFPreferencesAnyUser
from Foundation import kCFPreferencesCurrentUser
from Foundation import kCFPreferencesCurrentHost
import re
import time
import os

# our preferences "bundle_id"
BUNDLE_ID = 'MunkiReport'

class CurlError(Exception):
    def __init__(self, status, message):
        display_error(message)
        exit(0)

def set_verbosity(level):
    """
    Set verbosity level
    """
    munkicommon.verbose = int(level)

def display_error(msg, *args):
    """
    Call munkicommon error msg handler
    """
    munkicommon.display_error('Munkireport: %s' % msg, *args)

def display_warning(msg, *args):
    """
    Call munkicommon warning msg handler
    """
    munkicommon.display_warning('Munkireport: %s' % msg, *args)

def display_detail(msg, *args):
    """
    Call munkicommon detail msg handler
    """
    munkicommon.display_detail('Munkireport: %s' % msg, *args)

def curl(url, values):

    curl_path = pref('CurlPath') or '/usr/bin/curl'
    curl_cmd = [curl_path,
                '--silent', '--show-error', '--no-buffer',
                '--dump-header', '-',
                '--speed-time', '30',
                '--url', url,
                '--data', '@-']

    # Add (optional) Certificate info
    # Requires custom cURL binary compiled against OpenSSL or LibreSSL on 10.9+
    cert_info = pref('CertInfo')
    if cert_info:
        cacert = cert_info.get('cacert')
        capath = cert_info.get('capath')
        cert = cert_info.get('cert')
        key = cert_info.get('key')
        if cacert:
            if not os.path.isfile(cacert):
                raise CurlError(-1, 'No CA cert at %s' % cacert)
            curl_cmd.append('--cacert')
            curl_cmd.append(cacert)
        if capath:
            if not os.path.isdir(capath):
                raise CurlError(-2, 'No CA directory at %s' % capath)
            curl_cmd.append('--capath')
            curl_cmd.append(capath)
        if cert:
            if not os.path.isfile(cert):
                raise CurlError(-3, 'No client cert at %s' % cert)
            curl_cmd.append('--cert')
            curl_cmd.append(cert)
        if key:
            if not os.path.isfile(key):
                raise CurlError(-4, 'No client key at %s' % key)
            curl_cmd.append('--key')
            curl_cmd.append(key)

    proc = subprocess.Popen(curl_cmd, shell=False, bufsize=-1,
                            stdin=subprocess.PIPE,
                            stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    # Send values via stdin
    proc.stdin.write(urllib.urlencode(values))
    proc.stdin.close()
    display_detail('Sent request to %s' % url)

    donewithheaders = False
    maxheaders = 15
    header = {}
    output = ''
    while True:
        if not donewithheaders:
            info = proc.stdout.readline().strip('\r\n')
            if info.startswith('HTTP/'):
                header['http_result_code'] = info.split(None, 2)[1]
                header['http_result_description'] = info.split(None, 2)[2]
            elif ': ' in info:
                # got a header line
                part = info.split(None, 1)
                fieldname = part[0].rstrip(':').lower()
                header[fieldname] = part[1]
            elif info == '':
                # we got an empty line; end of headers (or curl exited)
                donewithheaders = True
        else:
            output = output + proc.stdout.readline()
            time.sleep(0.1)

        if proc.poll() != None:
            # For small download files curl may exit before all headers
            # have been parsed, don't immediately exit.
            maxheaders -= 1
            if donewithheaders or maxheaders <= 0:
                break

    retcode = proc.poll()
    if retcode:
        curlerr = ''
        try:
            curlerr = proc.stderr.read().rstrip('\n')
            curlerr = curlerr.split(None, 2)[2]
        except IndexError:
            pass
        if retcode == 22:
            # 22 means any 400 series return code. Note: header seems not to
            # be dumped to STDOUT for immediate failures. Hence
            # http_result_code is likely blank/000. Read it from stderr.
            if re.search(r'URL returned error: [0-9]+$', curlerr):
                header['http_result_code'] = curlerr[curlerr.rfind(' ')+1:]
        if curlerr:
            display_error(curlerr)
            exit(0)
    return output
    #except:
    #    display_error('A server error occurred: %s' % sys.exc_info()[0])
    #    exit(0)

def get_long_username(username):
    try:
        long_name = pwd.getpwnam(username)[4]
    except:
        long_name = ''
    return long_name.decode('utf-8')

def get_computername():
    cmd = ['/usr/sbin/scutil', '--get', 'ComputerName']
    proc = subprocess.Popen(cmd, shell=False, bufsize=-1,
                            stdin=subprocess.PIPE,
                            stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    (output, unused_error) = proc.communicate()
    output = output.strip()
    return output.decode('utf-8')

def get_cpuinfo():
    cmd = ['/usr/sbin/sysctl', '-n', 'machdep.cpu.brand_string']
    proc = subprocess.Popen(cmd, shell=False, bufsize=-1,
                            stdin=subprocess.PIPE,
                            stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    (output, unused_error) = proc.communicate()
    output = output.strip()
    return output.decode('utf-8')

def get_buildversion():
    cmd = ['/usr/bin/sw_vers', '-buildVersion']
    proc = subprocess.Popen(cmd, shell=False, bufsize=-1,
                            stdin=subprocess.PIPE,
                            stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    (output, unused_error) = proc.communicate()
    output = output.strip()
    return output.decode('utf-8')

def get_uptime():
    cmd = ['/usr/sbin/sysctl', '-n', 'kern.boottime']
    proc = subprocess.Popen(cmd, shell=False, bufsize=-1,
                            stdin=subprocess.PIPE,
                            stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    (output, unused_error) = proc.communicate()
    sec = int(re.sub('.*sec = (\d+),.*', '\\1', output))
    up = int(time.time() - sec)
    return up if up > 0 else -1


def set_pref(pref_name, pref_value):
    """Sets a preference, See munkicommon.py for details"""
    CFPreferencesSetValue(
        pref_name, pref_value, BUNDLE_ID,
        kCFPreferencesAnyUser, kCFPreferencesCurrentHost)
    CFPreferencesAppSynchronize(BUNDLE_ID)
    print "set pref"
    try:
        CFPreferencesSetValue(
            pref_name, pref_value, BUNDLE_ID,
            kCFPreferencesAnyUser, kCFPreferencesCurrentHost)
        CFPreferencesAppSynchronize(BUNDLE_ID)
    except Exception:
        pass


def pref(pref_name):
    """Return a preference. See munkicommon.py for details
    """
    pref_value = CFPreferencesCopyAppValue(pref_name, BUNDLE_ID)
    return pref_value

def process(serial, items):
    """Process receives a list of items, checks if they need updating
    and updates them if necessary"""

    # Sanitize serial
    serial = ''.join([c for c in serial if c.isalnum()])

    # Get prefs
    baseurl = pref('BaseUrl') or \
              munkicommon.pref('SoftwareRepoURL') + '/report/'

    hashurl = baseurl + "index.php?/report/hash_check"
    checkurl = baseurl + "index.php?/report/check_in"

    # Get passphrase
    passphrase = pref('Passphrase')

    # Get hashes for all scripts
    for key, i in items.items():
        if i.get('path'):
            i['hash'] = munkicommon.getmd5hash(i.get('path'))

    # Check dict
    check = {}
    for key, i in items.items():
        if i.get('hash'):
            check[key] = {'hash': i.get('hash')}

    # Send hashes to server
    values = {'serial': serial,\
             'items': serialize(check),\
             'passphrase' : passphrase}
    server_data = curl(hashurl, values)
    # = response.read()

    # Decode response
    try:
        result = unserialize(server_data)
    except:
        display_error('Illegal response from the server: %s' % server_data)
        return -1

    if result.get('error') != '':
        display_error('Server error: %s' % result['error'])
        return -1

    # Retrieve hashes that need updating
    for i in items.keys():
        if i in result:
            display_detail('Need to update %s' % i)
            if items[i].get('path'):
                try:
                    f = open(items[i]['path'], "r")
                    items[i]['data'] = f.read()
                except:
                    display_warning("Can't open %s" % items[i]['path'])

        else: # delete items that don't have to be uploaded
            del items[i]

    # Send new files with hashes
    if len(items):
        display_detail('Sending items')
        response = curl(checkurl, {'serial': serial,\
             'items': serialize(items),\
             'passphrase': passphrase})
        display_detail(response)
    else:
        display_detail('No changes')

def runExternalScriptWithTimeout(script, allow_insecure=False,\
        script_args=(), timeout=10):
    """Run a script (e.g. preflight/postflight) and return its exit status.

    Args:
      script: string path to the script to execute.
      allow_insecure: bool skip the permissions check of executable.
      args: args to pass to the script.
    Returns:
      Tuple. (integer exit status from script, str stdout, str stderr).
    Raises:
      ScriptNotFoundError: the script was not found at the given path.
      RunExternalScriptError: there was an error running the script.
    """
    from munkilib import utils

    if not os.path.exists(script):
        raise ScriptNotFoundError('script does not exist: %s' % script)

    if not allow_insecure:
        try:
            utils.verifyFileOnlyWritableByMunkiAndRoot(script)
        except utils.VerifyFilePermissionsError, e:
            msg = ('Skipping execution due to failed file permissions '
                   'verification: %s\n%s' % (script, str(e)))
            raise utils.RunExternalScriptError(msg)

    if os.access(script, os.X_OK):
        cmd = [script]
        if script_args:
            cmd.extend(script_args)
        proc = subprocess.Popen(cmd, shell=False,
                                stdin=subprocess.PIPE,
                                stdout=subprocess.PIPE,
                                stderr=subprocess.PIPE)
        while timeout > 0:
            if proc.poll() is not None:
                (stdout, stderr) = proc.communicate()
                return proc.returncode, stdout.decode('UTF-8', 'replace'), \
                                        stderr.decode('UTF-8', 'replace')
            time.sleep(0.1)
            timeout -= 0.1
        else:
            try:
                proc.kill()
            except OSError, e:
                if e.errno != 3:
                    raise
            raise utils.RunExternalScriptError('%s timed out' % script)
        return (0, None, None)

    else:
        raise utils.RunExternalScriptError('%s not executable' % script)

def rundir(scriptdir, runtype, abort=False, submitscript=''):
    """
    Run scripts in directory scriptdir
    runtype is passed to the script
    if abort is True, a non-zero exit status will abort munki
    submitscript is put at the end of the scriptlist
    """
    if os.path.exists(scriptdir):

        from munkilib import utils

        # Directory containing the scripts
        parentdir = os.path.basename(scriptdir)
        display_detail('# Executing scripts in %s' % parentdir)

        # Get all files in scriptdir
        files = os.listdir(scriptdir)

        # Sort files
        files.sort()

        # Find submit script and stick it on the end of the list
        if submitscript:
            try:
                sub = files.pop(files.index(submitscript))
                files.append(sub)
            except Exception, e:
                display_error('%s not found in %s' % (submitscript, parentdir))

        for script in files:

            # Skip files that start with a period
            if script.startswith('.'):
                continue

            # Concatenate dir and filename
            scriptpath = os.path.join(scriptdir, script)

            # Skip directories
            if os.path.isdir(scriptpath):
                continue

            try:
                # Attempt to execute script
                display_detail('Running %s' % script)
                result, stdout, stderr = runExternalScriptWithTimeout(
                    scriptpath, allow_insecure=False, script_args=[runtype])
                if stdout:
                    display_detail(stdout)
                if stderr:
                    display_detail('%s Error: %s' % (script, stderr))
                if result:
                    if abort:
                        display_detail('Aborted by %s' % script)
                        exit(1)
                    else:
                        display_warning('%s return code: %d'\
                            % (script, result))

            except utils.ScriptNotFoundError:
                pass  # Script has disappeared - pass.
            except Exception, e:
                display_warning("%s: %s" % (script, str(e)))



# End of reportcommon
